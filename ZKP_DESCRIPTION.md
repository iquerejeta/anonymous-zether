###ZKP description of the batch-zether proof

The big drawback in the work presented by Bunz, Agrawal, Zamani, and Boneh is that transactions are generated by zero knowledge proofs against a `state` of an account. This is, when generating a proof the proof is generated against the current state of the account, and in order to perform another payment (from or to that particular account) one has to wait until the chain gets updated in order to create the new zero knowledge proof. 

This however has big drawbacks for particular scenarios. Consider the following. We have a paying entity $A$ that whishes to perform one zether payment to a total of 1M different payee entities $P_1, \ldots, P_N$. The bottleneck here is waiting for the state to be updated after each payment. 

In this document we describe a batch zether payment scheme that allows a single entity to perform $N$ different payments in a single transaction, removing like that the bottleneck from the state update, and putting it in the proof generation. Furthermore, we present evaluation of the new generation proof, and how well this integrates with the Ethereum blockchain. 



#### The batch Zether proof

We assume that the reader is familiar with the work presented by Bunz _et al._ and we exclude a description of the protocol and / or the zero knowledge proof (page 14 of the original paper). 

It is clear from context that the work here presented does not modify the burn transaction proof. This is, when a user wants to decrypt its Zether balance, it will follow as presented in the original paper. 

Now, the transfer transaction proof is were the new proposal comes. Assume that entity $A$ wants to transfer an amount of $b_1, \ldots, b_N$ from a public key $y$ to public keys $y_{P_1}, \ldots, y_{P_N}$ respectively. Let $(C_L, C_R)$ be the encryption of the balance associated with $y$. The smart contract needs to deduct $b = \sum_{i=1}^N b_i$ from account $y$ and add $b_i$ to $y_{P_i}$ for $i \in \{1, \ldots, N\}$. Because it is of interest to hide $b, b_1, \ldots, b_N$, use $A$ needs to encrypt $b_i$ under both $y$ and $y_{P_i}$ to get $(C_i, D_i)$ and $(C_{P_i}, D_{P_i})$. Finally, it defines $(C_b, D_b)$ as $\prod_{i=1}^N (C_i, D_i)$. Now the proof needs to show the following for each $iâ€‹$: 

* Both ciphertexts are well formed and encrypt the same value $b_i$
* $b_i$ is a positive number

Additionally, it needs to prove the following:

* The remaining balance of $y$, say $b'$ is positive too

More formally, a user proves the following statement:
$$
\begin{aligned}
\texttt{st}_{\texttt{BatchTransfer}} : \{
(
y, y_{P_1}, \ldots, y_{P_N}, C_L, C_R, C_1, D_1, C_{P_1}, \ldots, C_N, D_N, C_{P_N}, g; \\ 
\texttt{sk}, b, b_1, \ldots, b_N, b', r_1, \ldots, r_N
):\\
C_1 = g^{b_1}y^{r_1} \wedge C_{P_1} = g^{b_1}y_{P_1}^{r_1} \wedge D_1 = g^{r_1} \wedge \ldots \wedge \\
C_N = g^{b_N}y^{r_N} \wedge C_{P_N} = g^{b_N}y_{P_N}^{r_N} \wedge D_N = g^{r_N} \wedge \\
C_L/\prod_{i=1}^N C_i = g^{b'}(C_R / \prod_{i=1}^N D_i)^{\texttt{sk}} \wedge y = g^{\texttt{sk}} \wedge \\
b_1\in\left[ 0, \texttt{MAX}\right] \wedge \ldots b_N\in\left[ 0, \texttt{MAX}\right], b'\in\left[ 0, \texttt{MAX}\right]\}
\end{aligned}
$$
As stated in the original paper, and first presented by Kurosawa, it is safe to use the same randomness to encrypt to multiple recipients. 

